/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.harbor.editor;

import java.awt.Component;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.Collection;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.JLabel;
import javax.swing.JTextField;
import javax.swing.LayoutStyle.ComponentPlacement;
import javax.swing.SwingConstants;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import org.harbor.domain.Ship;
import org.openide.awt.Mnemonics;
import org.openide.util.LookupEvent;
import org.openide.util.NbBundle;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.util.Lookup.Result;
import org.openide.util.LookupListener;
import org.openide.util.Utilities;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(dtd = "-//org.harbor.editor//HarborEditor//EN",
autostore = false)
@TopComponent.Description(preferredID = "HarborEditorTopComponent",
//iconBase="SET/PATH/TO/ICON/HERE", 
persistenceType = TopComponent.PERSISTENCE_ALWAYS)
@TopComponent.Registration(mode = "editor", openAtStartup = true)
@ActionID(category = "Window", id = "org.harbor.editor.HarborEditorTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(displayName = "#CTL_HarborEditorAction",
preferredID = "HarborEditorTopComponent")
public final class HarborEditorTopComponent
        extends TopComponent implements LookupListener {

    private Ship ship;

    public HarborEditorTopComponent() {

        initComponents();
        setName(NbBundle.getMessage(HarborEditorTopComponent.class, "CTL_HarborEditorTopComponent"));
        setToolTipText(NbBundle.getMessage(HarborEditorTopComponent.class, "HINT_HarborEditorTopComponent"));

        typeField.getDocument().addDocumentListener(new DocumentListener() {

            @Override
            public void insertUpdate(DocumentEvent e) {
                ship.setType(typeField.getText());
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
            }
        });

        yearField.getDocument().addDocumentListener(new DocumentListener() {

            @Override
            public void insertUpdate(DocumentEvent e) {
                ship.setYear(Integer.parseInt(yearField.getText()));
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
            }
        });



    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new JLabel();
        yearField = new JTextField();
        jLabel2 = new JLabel();
        typeField = new JTextField();
        Mnemonics.setLocalizedText(jLabel1, NbBundle.getMessage(HarborEditorTopComponent.class, "HarborEditorTopComponent.jLabel1.text"));

        yearField.setText(NbBundle.getMessage(HarborEditorTopComponent.class, "HarborEditorTopComponent.yearField.text")); // NOI18N
        Mnemonics.setLocalizedText(jLabel2, NbBundle.getMessage(HarborEditorTopComponent.class, "HarborEditorTopComponent.jLabel2.text"));

        typeField.setText(NbBundle.getMessage(HarborEditorTopComponent.class, "HarborEditorTopComponent.typeField.text")); // NOI18N

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addComponent(jLabel1))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(Alignment.TRAILING)
                    .addComponent(yearField, GroupLayout.DEFAULT_SIZE, 338, Short.MAX_VALUE)
                    .addComponent(typeField, GroupLayout.DEFAULT_SIZE, 338, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addGroup(layout.createParallelGroup(Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(typeField, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(yearField, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                .addContainerGap(219, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private JLabel jLabel1;
    private JLabel jLabel2;
    private JTextField typeField;
    private JTextField yearField;
    // End of variables declaration//GEN-END:variables

    @Override
    public void resultChanged(LookupEvent ev) {
        Collection<? extends Ship> allShipsICSW = shipsInCurrentlySelectedWindow.allInstances();
        for (Ship ship : allShipsICSW) {
            this.ship = ship;
            typeField.setText(ship.getType());
            yearField.setText(String.valueOf(ship.getYear()));
//            ship.addPropertyChangeListener(new PropertyChangeListener() {
//                @Override
//                public void propertyChange(PropertyChangeEvent evt) {
//                    if (evt.getPropertyName().equals("type")) {
//                        String newDisplayName = evt.getNewValue().toString();
//                        typeField.setText(newDisplayName);
//                    } else if (evt.getPropertyName().equals("year")) {
//                        String newToolTip = evt.getNewValue().toString();
//                        yearField.setText(newToolTip);
//                    }
//                }
//            });
        }
    }
    Result<Ship> shipsInCurrentlySelectedWindow;

    @Override
    public void componentOpened() {
        //The selected window:  
        shipsInCurrentlySelectedWindow = Utilities.actionsGlobalContext().lookupResult(Ship.class);
        shipsInCurrentlySelectedWindow.addLookupListener(this);
    }

    @Override
    public void componentClosed() {
        shipsInCurrentlySelectedWindow.removeLookupListener(this);
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }
}
